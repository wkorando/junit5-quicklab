- apiVersion: triggers.tekton.dev/v1alpha1
  kind: TriggerTemplate
  metadata:
    name: project-trigger-template
  spec:
    params:
      - name: path-to-context
        description: 'The path to the build context, used by Kaniko'
        default: /start/storm-tracker
      - name: path-to-deployment-file
        description: The path to the yaml file describe how to deploy the application.
        default: deployment.yaml
      - name: path-to-dockerfile
        description: The path to the docker image build file
        default: Dockerfile
      - name: api-url
        description: The api url for interacting with ibm cloud
        default: cloud.ibm.com
      - name: container-repo-url
        description: Base url for container repository
        default: us.icr.io
      - name: container-repo-namespace
        description: Namespace where image is located
        default: living-on-the-cloud
      - name: deployment-image
        description: Name of image to be deployed
        default: storm-tracker
      - name: name-of-cluster
        description: The number of cluster to deploy the image to
        default: living-on-the-cloud
      - name: cluster-region
        description: The region where the cluster resides
        default: us-south
      - name: cluster-namespace
        description: The namespace being used within the k8s cluster
        default: default
      - name: deployment-image-placeholder
        description: Placeholder value within deployment yaml to be replaced
        default: IMAGE
      - name: git-repo-url
        description: URL to the git repo to be cloned
      - name: commit-id
        description: The revision to build and deploy.
      - name: git-access-token
        description: The service account id the pipeline is run under
      - name: apikey
        description: >-
          Service Account API KEY for interacting with IBM Cloud note the
          specific syntax of apikey has special relevance to many IBM Cloud
          resources, so should not be changed.
    resourcetemplates:
      - apiVersion: tekton.dev/v1beta1
        kind: PipelineRun
        metadata:
          generateName: $(params.deployment-image)-build-
        spec:
          serviceAccountName: service-account
          pipelineRef:
            name: project-pipeline
          params:
            - name: path-to-context
              value: $(params.path-to-context)
            - name: path-to-deployment-file
              value: $(params.path-to-deployment-file)
            - name: path-to-dockerfile
              value: $(params.path-to-dockerfile)
            - name: api-url
              value: $(params.api-url)
            - name: container-repo-url
              value: $(params.container-repo-url)
            - name: container-repo-namespace
              value: $(params.container-repo-namespace)
            - name: cluster-namespace
              value: $(params.cluster-namespace)
            - name: deployment-image
              value: $(params.deployment-image)
            - name: name-of-cluster
              value: $(params.name-of-cluster)
            - name: cluster-region
              value: $(params.cluster-region)
            - name: git-access-token
              value: $(params.git-access-token)
            - name: git-repo-url
              value: $(params.git-repo-url)
            - name: commit-id
              value: $(params.commit-id)
            - name: deployment-image-placeholder
              value: $(params.deployment-image-placeholder)
          workspaces:
            - name: git-repo
              persistentVolumeClaim:
                claimName: $(uid)-pvc
      - apiVersion: v1
        stringData:
          username: iamapikey
          password: $(params.apikey)
        kind: Secret
        type: kubernetes.io/basic-auth
        metadata:
          name: ibm-cr-secret
          annotations:
            tekton.dev/docker-0: $(params.container-repo-url)
      - apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: $(uid)-pvc
        spec:
          resources:
            requests:
              storage: 5Gi
          volumeMode: Filesystem
          accessModes:
            - ReadWriteOnce
- apiVersion: tekton.dev/v1beta1
  kind: Pipeline
  metadata:
    name: project-pipeline
  spec:
    params:
      - name: path-to-context
      - name: path-to-deployment-file
      - name: path-to-dockerfile
      - name: cluster-namespace
      - name: api-url
      - name: container-repo-url
      - name: container-repo-namespace
      - name: deployment-image
      - name: deployment-image-placeholder
      - name: name-of-cluster
      - name: cluster-region
      - name: git-access-token
      - name: git-repo-url
      - name: commit-id
    workspaces:
      - name: git-repo
        description: Workspace for holding the cloned source code from the git-repo
    tasks:
      - name: git-clone
        taskRef:
          name: git-clone-repo
        params:
          - name: git-access-token
            value: $(params.git-access-token)
          - name: repository
            value: $(params.git-repo-url)
          - name: revision
            value: $(params.commit-id)
        workspaces:
          - name: output
            workspace: git-repo
      - name: build-artifact-from-source
        taskRef:
          name: maven-build-java-artifact-from-source
        runAfter:
          - git-clone
        params:
          - name: mvn-goals
            type: array
            value:
              - package
          - name: path-to-context
            value: $(params.path-to-context)
        workspaces:
          - name: source
            workspace: git-repo
      - name: build-image-send-to-cr
        taskRef:
          name: build-image-and-push-image
        runAfter:
          - build-artifact-from-source
        params:
          - name: container-repo-url
            value: $(params.container-repo-url)
          - name: container-repo-namespace
            value: $(params.container-repo-namespace)
          - name: deployment-image
            value: $(params.deployment-image)
          - name: path-to-context
            value: $(params.path-to-context)
        workspaces:
          - name: source
            workspace: git-repo
      - name: update-image-ref-in-deployment
        taskRef:
          name: update-yaml-file
        runAfter:
          - build-image-send-to-cr
        params:
          - name: path-to-deployment-file
            value: $(params.path-to-deployment-file)
          - name: path-to-context
            value: $(params.path-to-context)
          - name: placeholder-name
            value: $(params.deployment-image-placeholder)
          - name: replacement-value
            value: $(tasks.build-image-send-to-cr.results.full-image-path)
        workspaces:
          - name: source
            workspace: git-repo
      - name: deploy-image-to-ibm-cloud
        taskRef:
          name: deploy-image-to-ibm-cloud
        runAfter:
          - update-image-ref-in-deployment
        params:
          - name: path-to-deployment-file
            value: $(params.path-to-deployment-file)
          - name: path-to-context
            value: $(params.path-to-context)
          - name: name-of-cluster
            value: $(params.name-of-cluster)
          - name: cluster-region
            value: $(params.cluster-region)
          - name: api-url
            value: $(params.api-url)
          - name: cluster-namespace
            value: $(params.cluster-namespace)
        workspaces:
          - name: source
            workspace: git-repo
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: bind-ibm-service-to-cluster
  spec:
    params:
      - name: cluster-region
        description: Region where cluster is located
      - name: api-url
        description: API URL for interacting with IBM Cloud
        default: cloud.ibm.com
      - name: name-of-cluster
        description: The name of the cluster that the service will be bound to
      - name: name-of-service
        description: The name of the service that is being bound to a cluster
      - name: cluster-namespace
        description: The namespace on the k8s cluster where the service is being bound to
        default: default
    steps:
      - name: bind-service
        image: 'ibmcom/pipeline-base-image:2.7'
        env:
          - name: IBMCLOUD_API_KEY
            valueFrom:
              secretKeyRef:
                name: secure-properties
                key: apiKey
        command:
          - /bin/bash
          - '-c'
        args:
          - >-
            set -x -e -o pipefail; ibmcloud login -a $(params.api-url) -r
            $(params.cluster-region); export IKS_BETA_VERSION=1; ibmcloud ks
            cluster service bind $(params.name-of-cluster) --service
            $(params.name-of-service) --namespace $(params.cluster-namespace);
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: build-image-and-push-image
  spec:
    workspaces:
      - name: source
    params:
      - name: path-to-context
        description: 'The path to the build context, used by Kaniko - within the workspace'
        default: .
      - name: path-to-dockerfile
        description: The path to the dockerfile to build
        default: Dockerfile
      - name: container-repo-url
        description: Base url to the container repo
      - name: container-repo-namespace
        description: Namespace image is being stored under
      - name: deployment-image
        description: Name of image to be deployed
    results:
      - name: full-image-path
        description: The full path to the newly created image
    steps:
      - name: build-and-push
        image: gcr.io/kaniko-project/executor
        env:
          - name: BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
        command:
          - /kaniko/executor
        args:
          - '--dockerfile=$(params.path-to-dockerfile)'
          - >-
            --destination=$(params.container-repo-url)/$(params.container-repo-namespace)/$(params.deployment-image):$(BUILD_NUMBER)
          - '--context=dir:///workspace/source/$(params.path-to-context)'
      - name: print-full-image-path
        image: 'bash:latest'
        env:
          - name: BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
        script: >
          #!/usr/bin/env bash

          echo -n
          "$(params.container-repo-url)/$(params.container-repo-namespace)/$(params.deployment-image):${BUILD_NUMBER}"
          | tee /tekton/results/full-image-path;
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: create-ssl-secret
  spec:
    params:
      - name: name-of-cluster
        description: Name of cluster to deploy image to
      - name: cluster-region
        description: Region where cluster is located
      - name: api-url
        description: API URL for interacting with IBM Cloud
        default: cloud.ibm.com
      - name: cert-secret-key
        description: >-
          Key name for where certificate value is stored in secure-properties in
          toolchain.
      - name: cert-file-name
        description: >-
          The name of the file that the cerificate key will be stored in on the
          k8s cluster
      - name: cert-secret-name
        description: >-
          The name of the secret on the k8s cluster where the cert file will be
          stored
      - name: cluster-namespace
        description: The namespace on the k8s cluster where to to write the secret to
        default: default
    steps:
      - name: create-secret
        image: ibmcom/pipeline-base-image
        env:
          - name: IBMCLOUD_API_KEY
            valueFrom:
              secretKeyRef:
                name: secure-properties
                key: apiKey
          - name: CERTIFCATE
            valueFrom:
              secretKeyRef:
                name: secure-properties
                key: $(params.cert-secret-key)
        command:
          - /bin/bash
          - '-c'
        args:
          - >-
            set -x -e -o pipefail; ibmcloud login -a $(params.api-url) -r
            $(params.cluster-region); export IKS_BETA_VERSION=1; touch
            $(params.cert-file-name); echo $CERTIFCATE >>
            $(params.cert-file-name); ibmcloud ks cluster config -c
            $(params.name-of-cluster); kubectl -n $(params.cluster-namespace)
            create secret generic $(params.cert-secret-name)
            --from-file=$(params.cert-file-name);
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: deploy-image-to-ibm-cloud
  spec:
    params:
      - name: path-to-context
        description: 'The path to the build context, used by Kaniko - within the workspace'
        default: .
      - name: path-to-deployment-file
        description: The path to the yaml file to deploy within the git source
        default: deployment.yaml
      - name: name-of-cluster
        description: Name of cluster to deploy image to
      - name: cluster-region
        description: Region where cluster is located
      - name: api-url
        description: API URL for interacting with IBM Cloud
        default: cloud.ibm.com
      - name: cluster-namespace
        description: The namespace being used within the k8s cluster
        default: default
    workspaces:
      - name: source
    steps:
      - name: deploy-app
        image: 'ibmcom/pipeline-base-image:2.7'
        env:
          - name: IBMCLOUD_API_KEY
            valueFrom:
              secretKeyRef:
                name: secure-properties
                key: apikey
        command:
          - /bin/bash
          - '-c'
        args:
          - >-
            set -e -o pipefail; ibmcloud login -a $(params.api-url) -r
            $(params.cluster-region); export IKS_BETA_VERSION=1; ibmcloud ks
            cluster config -c $(params.name-of-cluster); kubectl apply -n
            $(params.cluster-namespace) -f
            $(workspaces.source.path)/$(params.path-to-context)/$(params.path-to-deployment-file);
- apiVersion: triggers.tekton.dev/v1beta1
  kind: EventListener
  metadata:
    name: github-push-event-listener
  spec:
    serviceAccountName: service-account
    triggers:
      - name: git-push-event-trigger
        template:
          name: project-trigger-template
        bindings:
          - name: github-push-trigger-binding
- apiVersion: triggers.tekton.dev/v1alpha1
  kind: TriggerBinding
  metadata:
    name: github-push-trigger-binding
  spec:
    params:
      - name: git-repo-url
        value: $(event.repository.git_url)
      - name: commit-id
        value: $(event.checkout_sha)
- apiVersion: triggers.tekton.dev/v1beta1
  kind: EventListener
  metadata:
    name: gitlab-push-event-listener
  spec:
    serviceAccountName: service-account
    triggers:
      - name: git-push-event-trigger
        template:
          name: project-trigger-template
        bindings:
          - name: gitlab-push-trigger-binding
- apiVersion: triggers.tekton.dev/v1alpha1
  kind: TriggerBinding
  metadata:
    name: gitlab-push-trigger-binding
  spec:
    params:
      - name: git-repo-url
        value: $(event.repository.git_http_url)
      - name: commit-id
        value: $(event.checkout_sha)
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: maven-build-java-artifact-from-source
  spec:
    workspaces:
      - name: source
    params:
      - name: mvn-goals
        type: array
        description: Goals to be run during maven build step
        default:
          - package
      - name: path-to-context
        description: Path to maven POM.xml file
        default: .
    steps:
      - name: list-src
        image: alpine
        command:
          - ls
        args:
          - $(workspaces.source.path)
      - name: mvn
        image: gcr.io/cloud-builders/mvn
        workingDir: /workspace/source/$(params.path-to-context)
        command:
          - /usr/bin/mvn
        args:
          - $(params.mvn-goals)
- apiVersion: v1
  kind: ServiceAccount
  metadata:
    name: service-account
  secrets:
    - name: ibm-cr-secret
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: update-yaml-file
  spec:
    params:
      - name: path-to-context
        description: 'The path to the build context, used by Kaniko - within the workspace'
        default: .
      - name: path-to-deployment-file
        description: The path to the yaml file to deploy within the git source
        default: deployment.yaml
      - name: placeholder-name
        description: Placeholder in yaml file that is too be replaced
      - name: replacement-value
        description: The value that will replace the place holder
    workspaces:
      - name: source
    steps:
      - name: update-yaml
        image: 'alpine:3.12'
        command:
          - sed
        args:
          - '-i'
          - '-e'
          - s;$(params.placeholder-name);$(params.replacement-value);g
          - >-
            $(workspaces.source.path)/$(params.path-to-context)/$(params.path-to-deployment-file)
- apiVersion: tekton.dev/v1alpha1
  kind: Condition
  metadata:
    name: skip-ci
  spec:
    params:
      - name: commit-message
      - name: skip-ci-pattern
        default: '.*\[\(skip ci\)\|\(ci skip\)\].*'
    check:
      image: alpine
      command:
        - /bin/sh
        - '-c'
      args:
        - echo "$(params.commit-message)" | grep -v '$(params.skip-ci-pattern)'
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: git-clone-repo
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: git-access-token
        description: >
          (optional) token to access the git repository. If this token is
          provided, there will not be an attempt

          to use the git token obtained from the authorization flow when adding
          the git integration in the toolchain
        default: ''
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: repository
        description: the git repo url
      - name: branch
        description: the git branch
        default: master
      - name: revision
        description: |
          the git revision/commit to update the git HEAD to.
          Default is to mean only use the branch
        default: ''
      - name: git-max-retry
        description: max retry for the git clone operation
        default: '1'
      - name: pr-repository
        description: >
          the originating repository where the PullRequest comes from (in case
          of a fork)

          default to '' means same repository (not a fork) or it can be the same
          as the repository to clone
        default: ''
      - name: pr-branch
        description: |
          the branch that is the source of this PullRequest
        default: ''
      - name: pr-revision
        description: >-
          the commit/revision in the source branch of the PullRequest that is to
          be built
        default: ''
      - name: directory-name
        description: >
          name of the new directory to clone into.

          Default to . in order to clone at the root of the workspace

          It will be set to the "humanish" part of the repository if this param
          is set to blank
        default: .
      - name: properties-file
        description: >-
          file containing properties out of clone task (can be a filepath name
          relative to the workspace)
        default: build.properties
      - name: git-credentials-json-file
        description: >
          JSON file containing the git credentials as found out of the clone
          task

          (can be a file path relative to the workspace).

          Default to '' meaning no output of this information
        default: ''
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    results:
      - name: git-repository
        description: The cloned repository
      - name: git-branch
        description: The active branch for the repository
      - name: git-commit
        description: The current commit id that was cloned
      - name: git-user
        description: The auth user that cloned the repository
    workspaces:
      - name: output
        description: The git repo will be cloned onto the volume backing this workspace
        mountPath: /artifacts
    stepTemplate:
      env:
        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: $(params.continuous-delivery-context-secret)
              key: $(params.ibmcloud-apikey-secret-key)
              optional: true
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: fetch-git-token
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: REPOSITORY
            value: $(params.repository)
        script: >
          #!/bin/bash

          set -e -o pipefail


          if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi


          TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

          TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json | awk
          -F: '{print $3}')

          ##########################################################################

          # Setting HOME explicitly to have ibmcloud plugins available

          # doing the export rather than env definition is a workaround

          # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

          export HOME="/root"

          ##########################################################################

          if [[ "$REPOSITORY" != *.git ]]; then
            echo "Adding .git suffix to Repository URL"
            REPOSITORY="${REPOSITORY}.git"
          fi

          GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY" \
            '.services[] | select (.parameters.repo_url==$git_repo) | .instance_id' /cd-config/toolchain.json)
          if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
            echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
            exit 1
          fi

          GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" \
            '.services[] | select (.parameters.repo_url==$git_repo) | .service_id' /cd-config/toolchain.json)

          if [ "$GIT_SERVICE_TYPE" == "github" ]; then
            GIT_AUTH_USER="x-oauth-basic"
          elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
            GIT_AUTH_USER="x-oauth-basic"
          elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
            GIT_AUTH_USER="oauth2"
          elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
            GIT_AUTH_USER="oauth2"
          elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
            GIT_AUTH_USER="x-token-auth"
          else
            GIT_AUTH_USER="x-token-auth"
          fi;


          GIT_TOKEN="$(params.git-access-token)"

          if [ -z "$GIT_TOKEN" ]; then
            echo "Fetching token for $REPOSITORY"
            ibmcloud config --check-version false
            ibmcloud login -a $(params.ibmcloud-api) -r $TOOLCHAIN_REGION --apikey $API_KEY
            if [ "$(params.resource-group)" ]; then
              ibmcloud target -g $(params.resource-group)
            fi
            TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
            GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' \
              /cd-config/toolchain.json)

            # GIT_TOKEN_URL is something like
            # https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
            # as there is already an url param git_id, just put the additional ones using &

            GIT_BROKER_URL="${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
            echo "Doing cURL to ${GIT_BROKER_URL}"

            curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" \
              -H "Authorization: $TOKEN" "$GIT_BROKER_URL"
            if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
              GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
              echo "Access token found for the Git integration (repository url: $REPOSITORY)"
            else
              echo "No access token found for the Git integration (repository url: $REPOSITORY)"
              cat /steps/github_token_result.json
              exit 1
            fi
          else
            echo "Using git Access Token provided"
          fi


          echo "GIT_REPOSITORY=$REPOSITORY" > /steps/next-step-env.properties

          echo "GIT_AUTH_USER=$GIT_AUTH_USER" >> /steps/next-step-env.properties

          echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: clone-repo
        image: alpine/git
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: BRANCH
            value: $(params.branch)
          - name: REVISION
            value: $(params.revision)
          - name: PR_REPOSITORY
            value: $(params.pr-repository)
          - name: PR_BRANCH
            value: $(params.pr-branch)
          - name: PR_REVISION
            value: $(params.pr-revision)
          - name: DIRECTORY_NAME
            value: $(params.directory-name)
          - name: PROPERTIES_FILE
            value: $(params.properties-file)
          - name: JSON_FILE_GIT_CREDENTIALS
            value: $(params.git-credentials-json-file)
        script: >
          #!/bin/sh

          set -e


          if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi


          ############################

          # Workaround until a null/empty param can be flowing to Task

          # REVISION if not set is define with a single blank value

          BRANCH=$(echo $BRANCH)

          REVISION=$(echo $REVISION)

          PR_REPOSITORY=$(echo $PR_REPOSITORY)

          PR_BRANCH=$(echo $PR_BRANCH)

          PR_REVISION=$(echo $PR_REVISION)

          ############################

          source /steps/next-step-env.properties


          # If $BRANCH is a full git ref then only keep the name part

          BRANCH=$(echo ${BRANCH#"refs/heads/"})


          echo "Cloning $REPOSITORY"

          # Add the proper creds to the git repository

          GIT_URL=$(echo "$REPOSITORY" | sed -e
          "s/:\/\//:\/\/$GIT_AUTH_USER:$GIT_TOKEN@/g")

          ARTIFACTS_PATH="$(workspaces.output.path)"

          cd $ARTIFACTS_PATH

          if [ "$REVISION" ]; then
            # check if the branch exists (that may not be the case in case of a pipeline-run re-run)
            echo "Fetching specific -${REVISION}- commit"
            if [ -z "$BRANCH" ]; then
              # No branch provided
              _clone_command='git clone -q -n $GIT_URL $DIRECTORY_NAME'
            elif git ls-remote --heads --exit-code $GIT_URL $BRANCH > /dev/null 2>&1; then
              _clone_command='git clone -q -b "$BRANCH" $GIT_URL $DIRECTORY_NAME'
            else
              echo "branch $BRANCH does not exists in $REPOSITORY"
              _clone_command='git clone -q -n $GIT_URL $DIRECTORY_NAME'
            fi
          else
            if [ -z "$BRANCH" ]; then
              # No branch provided
              echo "No branch or revision provided."
              _clone_command='git clone -q -n $GIT_URL $DIRECTORY_NAME'
            else
              _clone_command='git clone -q -b "$BRANCH" $GIT_URL $DIRECTORY_NAME'
            fi
          fi

          _max_retry=$(params.git-max-retry)

          set +e

          eval "$_clone_command"

          _clone_code=$?

          _retry_counter=1

          while [ $_retry_counter -le $_max_retry ]; do
              if [ $_clone_code != 0 ]; then
                echo "Clone was not successful. Code $_clone_code - Retrying shortly..."
                sleep 10
                if [ $_retry_counter -eq $_max_retry ]; then
                    set -e # reset on the last attempt so we fail if all attemps fail
                fi
                eval "$_clone_command"
                let "_retry_counter++"
              else
                break
              fi
          done

          echo "Repository $REPOSITORY successfully cloned"

          set -e


          current_dir=$(pwd)

          if [ -z "$DIRECTORY_NAME" ]; then
            # Find the "humanish" part of the git source repository that corresponds to the clone directory
            # GIT_REPOSITORY contains the repository url with .git suffix
            DIRECTORY_NAME=$(basename "${GIT_REPOSITORY##*/}" .git)
          fi

          cd $DIRECTORY_NAME

          if [ "$REVISION" ]; then
            # Point the HEAD to the specific revision
            git checkout -q $REVISION
          fi

          GIT_COMMIT=$(git show-ref --head | head -n1 | awk '{print $1}')


          # If a Pull Request/Merge Request branch is specified, then

          # execute the git commands to have the cloned git repository directory
          content

          # to be the result of the merge for pull request/merge request

          if [ "${PR_BRANCH}" ]; then
            echo "Performing Pull Request Checkout & Merge"
            git config --global user.email "cdtektonpipeline@ibm.com"
            git config --global user.name "CD Tekton Pipeline"
            # Clear GIT_COMMIT as the outcome if this task is a non yet known commit
            GIT_COMMIT=""
            if [ -z "$PR_REPOSITORY" ] || [ "$PR_REPOSITORY" == "$REPOSITORY" ]; then
              # Assuming the PR is not coming from a fork as $PR_REPOSITORY is empty or equals to $REPOSITORY
              # Make the manual steps that a merge request action is doing
              git fetch -q origin "${PR_BRANCH}"
              if [ "${PR_REVISION}" ]; then
                if git merge "${PR_REVISION}"; then
                  echo "git merge ${PR_REVISION} done"
                else
                  exit 1
                fi
              else
                if git merge "origin/${PR_BRANCH}"; then
                  echo "git merge origin/${PR_BRANCH} done"
                else
                  exit 1
                fi
              fi
              echo -n "git merge of $GIT_REPOSITORY (pr-branch ${PR_BRANCH} - pr_commit ${PR_REVISION}) to "
              echo "(branch $BRANCH - commit $REVISION) done in directory $DIRECTORY_NAME"
            else
              # Assuming the PR is from a fork
              # Expect that the same creds will be sufficient for the git pull from the forked repository
              GIT_PR_REPO_URL=$(echo "$PR_REPOSITORY" | sed -e "s/:\/\//:\/\/$GIT_AUTH_USER:$GIT_TOKEN@/g")
              # Make the manual steps that a merge request action is doing
              # Step 1
              if git pull "${GIT_PR_REPO_URL}" "${PR_BRANCH}"; then
                echo "git pull ${PR_REPOSITORY} ${PR_BRANCH} done"
              else
                exit 1
              fi
              if [ "$PR_REVISION" ]; then
                git checkout -q "$PR_REVISION"
              fi
              # create a specific branch to hold the PR state
              git checkout -q -b cd-tekton-pipeline-temp-branch-for-pr
              # Step 2
              git checkout -q "${BRANCH}"
              if git merge cd-tekton-pipeline-temp-branch-for-pr; then
                echo -n "git merge of $PR_REPOSITORY (pr-branch ${PR_BRANCH} - pr_commit ${PR_REVISION}) to $REPOSITORY"
                echo " (branch $BRANCH - commit $REVISION) done in directory $DIRECTORY_NAME"
              else
                exit 1
              fi
            fi
          else
            echo "git clone of $GIT_REPOSITORY (branch $BRANCH - commit $GIT_COMMIT) done in directory $DIRECTORY_NAME"
          fi

          cd $current_dir

          if [ "$PROPERTIES_FILE" ]; then
            # Ensure directory is there
            mkdir -p $ARTIFACTS_PATH/$(dirname "$PROPERTIES_FILE")
            echo "GIT_URL=$REPOSITORY" >> $ARTIFACTS_PATH/$PROPERTIES_FILE
            echo "GIT_BRANCH=$BRANCH" >> $ARTIFACTS_PATH/$PROPERTIES_FILE
            echo "GIT_COMMIT=$GIT_COMMIT" >> $ARTIFACTS_PATH/$PROPERTIES_FILE
            # Change  write access permission to allow subsequent task(s) to update if needed
            chmod go+rw $ARTIFACTS_PATH/$PROPERTIES_FILE
            echo "$PROPERTIES_FILE content:"
            cat $ARTIFACTS_PATH/$PROPERTIES_FILE
          fi

          if [ "$JSON_FILE_GIT_CREDENTIALS" ]; then
            # Ensure directory is there
            mkdir -p $ARTIFACTS_PATH/$(dirname "$JSON_FILE_GIT_CREDENTIALS")
            # Create a JSON file as output of this step to store the git credentials for future use
            echo "{" > "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
            echo "\"GIT_REPOSITORY\":\"${REPOSITORY}\"," >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
            echo "\"GIT_AUTH_USER\":\"${GIT_AUTH_USER}\"," >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
            echo "\"GIT_TOKEN\":\"${GIT_TOKEN}\"" >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
            echo "}" >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
          fi


          # Record task results

          echo -n "${REPOSITORY}" > $(results.git-repository.path)

          echo -n "${BRANCH}" > $(results.git-branch.path)

          echo -n "${GIT_COMMIT}" > $(results.git-commit.path)

          echo -n "${GIT_AUTH_USER}" > $(results.git-user.path)
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: git-set-commit-status
    description: This task will set CI status on the commit
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: git-access-token
        description: >
          (optional) token to access the git repository. If this token is
          provided, there will not be an attempt

          to use the git token obtained from the authorization flow when adding
          the git integration in the toolchain
        default: ''
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: repository
        description: |
          The git repository url
      - name: revision
        description: |
          (optional) Commit SHA to set the status for.
          If left empty, will attempt to read GIT_COMMIT from build-properties
        default: ''
      - name: description
        description: |
          A short description of the status.
      - name: context
        description: |
          A string label to differentiate this status from
          the status of other systems. ie: "continuous-integration/tekton"
        default: continuous-integration/tekton
      - name: state
        description: >
          The state of the status. Can be one of the following: `pending`,
          `running`, `success`, `failed`, `canceled`

          or a value meaningful for the target git repository

          - gitlab/hostedgit: `pending`, `running`, `success`, `failed`,
          `canceled`

          - github/integrated github: `pending`, `success`, `failure`, `error`

          - bitbucket: `SUCCESSFUL`, `FAILED`, `INPROGRESS`, `STOPPED`
        default: ''
      - name: state-var
        description: >
          Customized variable stored in build-properties to use as state if
          state params is empty.
        type: string
        default: ''
      - name: build-properties
        description: >
          file containing properties out of clone task (can be a filepath name
          relative to the workspace/volume)
        default: build.properties
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    workspaces:
      - name: artifacts
        description: >
          Workspace that may contain git repository information (ie
          build.properties).

          Should be marked as optional when Tekton will permit it
        mountPath: /artifacts
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: fetch-git-information
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail


            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################

            if [[ "$REPOSITORY" != *.git ]]; then
              echo "Adding .git suffix to Repository URL"
              REPOSITORY="${REPOSITORY}.git"
            fi

            GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .instance_id' /cd-config/toolchain.json)
            if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
              echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
              exit 1
            fi

            GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .service_id' /cd-config/toolchain.json)
            if [ "$GIT_SERVICE_TYPE" == "github" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
              GIT_AUTH_USER="x-token-auth"
            else
              GIT_AUTH_USER="x-token-auth"
            fi;

            GIT_TOKEN="$(params.git-access-token)"

            if [ -z "$GIT_TOKEN" ]; then
              echo "Fetching token for $REPOSITORY"
              ibmcloud config --check-version false
              ibmcloud login -a $(params.ibmcloud-api) -r $TOOLCHAIN_REGION --apikey $API_KEY
              if [ "$(params.resource-group)" ]; then
                ibmcloud target -g $(params.resource-group)
              fi
              TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
              GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" \
                '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' \
                /cd-config/toolchain.json)

              # GIT_TOKEN_URL is something like
              # https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
              # as there is already an url param git_id, just put the additional ones using &

              GIT_BROKER_URL="${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              echo "Doing cURL to ${GIT_BROKER_URL}"

              curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" \
                -H "Authorization: $TOKEN" "$GIT_BROKER_URL"
              if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
                GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
                echo "Access token found for the Git integration (repository url: $REPOSITORY)"
              else
                echo "No access token found for the Git integration (repository url: $REPOSITORY)"
                cat /steps/github_token_result.json
                exit 1
              fi
            else
              echo "Using git Access Token provided"
            fi


            GIT_API_ROOT_URL=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.api_root_url' \
              /cd-config/toolchain.json)
            GIT_OWNER_ID=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.owner_id' /cd-config/toolchain.json)
            GIT_REPO_NAME=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.repo_name' /cd-config/toolchain.json)
            GIT_ID=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.git_id' /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')


            echo "GIT_REPOSITORY=$REPOSITORY" > /steps/next-step-env.properties

            echo "GIT_AUTH_USER=$GIT_AUTH_USER" >>
            /steps/next-step-env.properties

            echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties

            echo "GIT_SERVICE_TYPE=$GIT_SERVICE_TYPE" >>
            /steps/next-step-env.properties

            echo "GIT_ID=$GIT_ID" >> /steps/next-step-env.properties

            echo "GIT_API_ROOT_URL=$GIT_API_ROOT_URL" >>
            /steps/next-step-env.properties

            echo "GIT_OWNER_ID=$GIT_OWNER_ID" >> /steps/next-step-env.properties

            echo "GIT_REPO_NAME=$GIT_REPO_NAME" >>
            /steps/next-step-env.properties

            echo "TOOLCHAIN_REGION=$TOOLCHAIN_REGION" >>
            /steps/next-step-env.properties


            if [ $PIPELINE_DEBUG == 1 ]; then
              cat /steps/next-step-env.properties
            fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: set-status
        image: 'registry.access.redhat.com/ubi8/ubi:8.1'
        env:
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: PIPELINE_RUN_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
        script: >
          #!/usr/libexec/platform-python

          import json

          import os

          import sys

          import urllib.request

          import urllib.parse


          # extract the previouly properties found in previous step

          previous_step={}

          if os.environ["PIPELINE_DEBUG"] == "1":
            print("previous step properties:")
          f = open("/steps/next-step-env.properties", "r")

          for x in f:
            if os.environ["PIPELINE_DEBUG"] == "1":
              print(x)
            prop = x.split("=", 1)
            previous_step[prop[0]] = prop[1].strip()
          f.close()


          # extract the build properties in their own structure

          build={}

          if os.path.exists("/artifacts/$(params.build-properties)"):
            if os.environ["PIPELINE_DEBUG"] == "1":
              print("$(params.build-properties):")
            f = open("/artifacts/$(params.build-properties)", "r")
            for x in f:
                if os.environ["PIPELINE_DEBUG"] == "1":
                  print(x)
                prop = x.split("=", 1)
                build[prop[0]] = prop[1].strip()
            f.close()

          # find the state

          state = "$(params.state)"

          if "$(params.state-var)" != "":
            print("Looking for state in $(params.build-properties)")
            state = build["$(params.state-var)"]

          # Make the state value consistent to the git flavor

          # Generic state values are: pending, running, success, failed,
          canceled

          # Define mapping from generic to git flavor to put the appropriate
          value for git target

          # Allowed Github state values: pending, success, failure, error

          state_mapping_generic_to_github = {
            "failed": "failure",
            "canceled": "error",
            "running": "pending"
          }

          # Gitlab: pending, running, success, failed, canceled

          # no mapping for gitlab as generic state value are identical

          # Allowed Bitbucket state values: SUCCESSFUL, FAILED, INPROGRESS,
          STOPPED

          state_mapping_generic_to_bitbucket = {
            "pending": "INPROGRESS",
            "running": "INPROGRESS",
            "success": "SUCCESSFUL",
            "failed": "FAILED",
            "canceled": "STOPPED"
          }


          # find the commit to set status on

          revision = "$(params.revision)"

          if revision == "":
            revision = build["GIT_COMMIT"]

          description="$(params.description)"


          context="$(params.context)"


          # compute the target url of this pipeline run

          target_url = ("https://cloud.ibm.com/devops/pipelines/tekton/" +
          os.environ["PIPELINE_ID"] +
            "/runs/" + os.environ["PIPELINE_RUN_ID"] + "?env_id=ibm:yp:" + previous_step["TOOLCHAIN_REGION"])

          # Create the request object according to the Git Falvor API

          if previous_step["GIT_ID"] == "gitlab" or previous_step["GIT_ID"] ==
          "hostedgit" :
            status_url = (previous_step["GIT_API_ROOT_URL"]
              + "/v4/projects/" + previous_step["GIT_OWNER_ID"] + "%2F" + previous_step["GIT_REPO_NAME"]
              + "/statuses/" + revision)
            params = {
              "state": state,
              "description": description,
              "context": context,
              "target_url": target_url
            }
            url_query_params = urllib.parse.urlencode(params)
            req = urllib.request.Request(
              status_url + "?" + url_query_params,
              data=None,
              headers={
                  "Authorization": "Bearer " + previous_step["GIT_TOKEN"]
              },
              method="POST"
            )
          elif previous_step["GIT_ID"] == "bitbucketgit":
            status_url = (previous_step["GIT_API_ROOT_URL"]
              + "/2.0/repositories/" + previous_step["GIT_OWNER_ID"] + "/" + previous_step["GIT_REPO_NAME"]
              + "/commit/" + revision + "/statuses/build")

            if state in state_mapping_generic_to_bitbucket:
              bitbucket_state = state_mapping_generic_to_bitbucket[state]
            else:
              # No mapping found - use the state value provided
              bitbucket_state = state
            print("State value '" + state + "' mapped to bitbucket state '" + bitbucket_state + "'")

            data = {
              "key": os.environ["PIPELINE_ID"],
              "url": target_url,
              "state": bitbucket_state,
              "name": context,
              "description": description
            }
            req = urllib.request.Request(
              status_url,
              data=json.dumps(data).encode('utf8'),
              headers={
                  "content-type": "application/json",
                  "Authorization": "Bearer " + previous_step["GIT_TOKEN"]
              },
              method="POST"
            )
          else:
            # Default to github
            if previous_step["GIT_ID"] == "integrated":
              api_prefix="/v3"
            else:
              api_prefix=""

            if state in state_mapping_generic_to_github:
              github_state = state_mapping_generic_to_github[state]
            else:
              # No mapping found - use the state value provided
              github_state = state

            print("State value '" + state + "' mapped to github state '" + github_state + "'")

            status_url = (previous_step["GIT_API_ROOT_URL"] + api_prefix
              + "/repos/" + previous_step["GIT_OWNER_ID"] + "/" + previous_step["GIT_REPO_NAME"]
              + "/statuses/" + revision)
            data = {
              "state": github_state,
              "target_url": target_url,
              "description": description,
              "context": context
            }
            req = urllib.request.Request(
              status_url,
              data=json.dumps(data).encode('utf8'),
              headers={
                  "content-type": "application/json",
                  "Authorization": "Bearer " + previous_step["GIT_TOKEN"]
              },
              method="POST"
            )

          req.add_header("User-Agent", "TektonCD, the peaceful cat")


          with urllib.request.urlopen(req) as resp:
            if not str(resp.status).startswith("2"):
              print("Error: %d" % (resp.status))
              print(resp.read())
              sys.exit(1)
            else:
              print(previous_step["GIT_ID"] + " commit status '" + state + "' has been set on "
                + previous_step["GIT_REPOSITORY"] + "#" + revision)
              if os.environ["PIPELINE_DEBUG"] == "1":
                print("Status: %d" % (resp.status))
                print(resp.read())
              sys.exit(0)
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
